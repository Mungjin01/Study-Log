
## Thread

: 프로세스의 작업 흐름

싱글스레드 → 한 번에 하나의 작업만 수행

멀티스레드 → 동시에 여러 작업을 수행

![스레드1-1.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/vB20nrggHe.png)

- 서버에게 서비스 요청이 들어오면 프로세스는 그 요청을 수행할 별도의 프로세스를 생성
- but 프로세스 생성 작업은 많은 시간과 자원을 소비해야 하므로 오버헤드가 많아짐 → 프로세스 안에서 여러 스레드 만들어나가는 것이 효율적이다.
- 커널 안에서 다수의 스레드들이 동작하고 각 스레드는 인터럽트 처리 등 작업 수행

멀티스레드 프로그래밍 장점 4가지

1. 응답성
    1. interactive application을 멀티스레딩하면 일부분이 blocking되거나 긴 작업을 수행해도 프로그램의 수행이 계속되도록 해서 responsivess 향상
2. 자원 공유
    1. 공유 메모리와 메시지 전달 기법을 통해 자원 공유
    2. → 같은 address space 내에 여러 개의 다른 작업을 하는 Thread를 가질 수 있다
3. 경제성
    1. 자신이 속한 process의 자원들을 공유하기에 thread를 생성하여 context-switch하는 것이 경제적
4. 규모 적응성

## 다중 코어 프로그래밍

멀티코어 시스템안의 멀티쓰레딩

- 동시성 개선

- single-core: 쓰레들들 시산이 지남에 따라 interleaved해서 쓰레드들 중간에 공백의 시간 존재
    
    ![스레드와동시성 1-1.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/b3Gme1IL8h.png)
    
- multiple-cores: 여러 개의 쓰레드들이 병렬적으로 수행ㄱㄴ
    
    ![스레드와동시성 1-2.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/ScCUSIsBWa.png)
    

**Multicore systems에서 프로그래밍 도전**

- 테스크 식별 → 테스크를 나누어 수행할 영역 찾기
- 균형 → 동일한 가치의 작업 수행할 수 있도록 보장
- 데이터 분할 → 데이터 또한 여러 개의 코어가 놓지 않도록 잘 나누기
- 데이터 의존성: 데이터 의존성을 수용하도록 테스크의 실행이 동기화
- 데스트와 디버깅

**병렬 실행의 유형**

1. 데이터 병렬 실행

→ 동일한 data의 부분 집합을 다수의 계산 코어에 분배해서 각 코어에서 동일한 연산 수행

1. 태스크 병렬 실행

→ data가 아닌 task를 다수의 코어에 분배

⇒ data parallelism은 data가 core에 분배되어야 하고 task parallesim은 task가 분배

## 다중 쓰레드 모델

- 다대일 모델(Many-to-One Model)
- 일대일 모델(One-to-One Model)
- 다대다 모델(Many-to-Many Model)
- 다대다 모델의 변형, 두 수준 모델(Two-Level Model)

### 1. 다대일 모델

- 여러 개의 사용자 수준 쓰레드를 하나의 커널 쓰레드에 매핑
- 하나의 사용자 쓰레드가 블록되면 전체 프로세스가 봉쇄
- 다중 쓰레드가 다중 처리기에서 수행되어도 병렬로 작동 불가능

![스레드와동시성 1-3.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/pxZz1v9TOq.png)

### 2. 일대일 모델

- 각각의 사용자 쓰레드가 각각의 커널 쓰레드에 매핑
- 하나의 쓰레드가 블록되어도 다른 쓰레드가 수행 가능하기 때문에 많은 병렬성 제공
- 다중 처리기에서 다중 쓰레드가 병렬로 수행되는 것을 허용

but 사용자 쓰레드를 생성할 때 커널 쓰레드도 생성되기에 응용 프로그램 성능 정하됨

![스레드와동시성 1-4.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/mZzq3Ycqxx.png)

### 3. 다대다 모델

- 여러 개의 사용자 수준 쓰레드를 그보다 작거나 같은 수의 커널 쓰레드로 매핑
- 하나의 사용자 쓰레드가 블록되어도 다른 사용자 쓰레드 실행 ㄱㄴ
- 개발자가 필요한 만큼의 사용자 쓰레드 생성 ㄱㄴ

![스레드와동시성 1-5.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/0E8EqcCnuR.png)

### 4. 두 수준 모델

- 하나의 사용자 쓰레드가 하나의 커널 쓰레드에 종속되도록 함
- 다대다 모델의 변형

![스레드와동시성 1-6.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/b3Gme1IL8h.png)


## 스레드 라이브러리

스레드 라이브러리는 프로그래머에게 스레드를 생성 관리하기 위한 api를 제공한다

스레드 라이브러리 구현 방법

- 커널 지원없이 사용자 공간에서만 라이브러리를 제공
- 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현

대표적인 스레드 라이브러리

- POSIX Pthread
- Windows
- Java

스레딩에는 2가지 종류가 있는데

1. 동기 스레딩
    1. 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드가 모두 종료할 때까지 기다렸다가 자신의 실행을 재개
2. 비동기 스레딩
    1. 부모 스레드가 자식 스레드를 생성한 후, 부모는 자신의 실행을 재개하여 두 스레드를 병행하게 실행
    2. 각 스레드는 모두 다른 스레드와 독립적으로 실행해서 부모 스레드는 자식의 종료를 알 필요가 x
    

## 스레딩 이슈들

다중 쓰레드 프로그램을 사용할때 고려해야할 점들이 많다

- 쓰레드의 fork() 및 exec() 시스템 호출 문제
- 쓰레드의 취소(Cancellation)
- 쓰레드의 신호 처리(Signal Handling)
- 쓰레드 풀(Thread pool)
- 쓰레드별 데이터(Thread-Specific Data)
- 스케줄러 활성화(Scheduler Activation)

### 1. 스레드의 fork() 및 exec() 시스템 콜 호출

fork() 시스템 콜을 호출하면 새로운 프로세스 공간을 별도로 생성하고, fork() 시스템 콜을 호출한 부모 프로세스 공간의 데이터들을 모두 복사

1. 부모 프로세스가 사용하는 모든 쓰레드를 복사함
2. 부모 프로세스에서 fork()를 호출한 쓰레드만 복사함

exec() 시스템 콜 호출은 유닉스,리눅스 시스템 콜 중 하나

exec() 시스템 콜을 호출하면 별도의 프로세스 공간을 생성하지 않고 exec()의 매개변수로 지정한 프로세스로 대체한다

If 어떤 프로세스안의 스레드가 fork()를 호출한 다음 exec()를 호출한다면 어떻게 설계하는게 좋을까?

1.  부모 프로세스가 사용하는 모든 스레드를 복사함
    
    →  모든 스레드를 복사하고 exec() 호출하여 새로운 프로세스로 대체됨 
    
2. 부모 프로세스에서 fork()를 호출한 쓰레드만 복사함
    
    → fork()를 호출한 쓰레드만 복사된 다음 exec()를 호출하여 새로운 프로세스로 대체됨
    

### 2. 스레드의 취소

: 쓰레드가 끝나기 전에 그것을 강제 종료시키는 행위

ex) 스레드들이 데이터베이스를 병렬로 검색하고 있다가 원하는 결과를 찾으면 남은 스레드들은 취소되어도 되는데 이렇게 취소되어야 할 스레드들을 목적 스레드라고 한다.

1. 비동기식 취소(asynchronous cancellation) : 한 쓰레드가 즉시 목적 쓰레드를 강제 종료
2. 지연 취소(deterred cancellation) : 목적 쓰레드가 주기적으로 자신이 강제 종료되어야 할 시기를 점검함.

그럼 왜 목적 스레드의 비동기식 취소 방식은 문제가 될까?

1. 목적 스레드에 할당된 자원때문
    1. 목적  스레드들이 갑자기 강제 종료가 되면 할당된 자원들이 올바르게 해제되지 않을 수 있다
2. 목적 스레드가 다른 스레드와 공유하는 자료 구조를 갱신하는 도중에 취소 요청이 올 때 문제 발생

이렇게 비동기식 취소 방식으로 목적 스레드들을 취소한다면 시스템 자원을 다 사용가능한 상태로 만들지 못 할 수도 있다

### 3. 스레드의 신호 처리

신호는 운영체제에서 프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용되는데 알려줄 event의 source나 reason에 따라 동기식, 비동기식으로 전달될 수 있다

- 동기식 신호: 실행 중인 프로그램이 불법적인 메모리 접근, 0으로 나누기 등의 행위를 했을 때 발생한다.
- 비동기식 신호: 프로세스 외부로부터 신호가 발생해서 프로세스에게 신호 순서를 무시하고 전달하는 신호이다

모든 신호는 둘 중 하나의 handler에게 처리된다

1. 디폴트 신호 처리기 : 모든 신호마다 커널에 의해 실행되는 처리기
2. 사용자 정의 신호 처리기 : 특정 신호에 사용자가 정의한 방식으로 처리되는 처리기
    - 신호는 다른 방식으로 처리될 수 있음
    - 불법적인 메모리 접근 같은 신호는 강제 종료시켜 처리할 수 있음

단일 스레드 프로세스의 신호 처리는 간단하나 다중 스레드 프로세스는 그렇지 않다.. 

어느 스레드에게 신호를 전달해야 할까?

다중 스레드 프로세스에서 신호 발생시 전달 스레드 선택의 경우

1. 신호가 적용될 스레드에게 전달 (단일)
2. 모든 스레드에게 전달
3. 몇몇 스레드들에게만 선택적으로 전달
4. 특정 스레드가 모든 신호를 전달받도록 지정

동기식 신호 - 신호가 적용될 스레드에게 전달

비동기식 신호 - 모든 스레드에게 전달

### 4. 스레드 풀

웹 서버는 요청을 받을 때마다 그 요청을 들어주기 위해 새로운 Thread를 생성하는데 이 방법에는 2가지 문제가 있을 수 있다

1. 서비스를 할 때마다 스레드를 생성하는데 일정 시간이 소요된다
2. 모든 요청마다 스레드를 생성하므로 동시에 실행할 수 있는 최대 스레드의 수를 정해놓아야 한다.

프로세스를 시작할 때 아예 일정한 수의 스레드를 미리 pool로 만들어 놓는 것

- pool에 만들어진 스레드들은 일이 없을 때는 일을 계속 기다리게 됨
- 이후 request가 들어오면 pool에 한 스레드에게 해당 request 할당
- 만약 pool에 남아있는 Thread가 없으면, server는 free 스레드가 생길 때까지 기다려야한다.

### 5. 스레드별 데이터

: 스레드만이 가지고 있는 자원

![스레드와동시성 1-7.PNG](https://i.esdrop.com/d/f/AfOYjCl4ON/GZqiWd79NA.png)

### 6. 스케줄러 활성화

: 사용자 스레드 라이브러리와 커널 스레드간의 통신을 하는 방법

동작 과정

1. 커널은 application에게 LWP의 set제공
2. application은 virtual processor로 유저 스레드를 schedule
3. 커널은 application에게 특정 사건 알려줌

ex)

 upcall을 일으키는 특정 사건

upcall은 사용자 스레드가 봉쇄(입/출력같은 이벤트)하려고 할때 발생할 수 있다. 이때 upcall을 처리하는 과정

1. 사용자 스레드가 봉쇄되려고 할때 커널은 스레드가 봉쇄하려고 한다는 사실과 그 스레드의 식별자를 알려주는 upcall을 수행함
2. 커널은 새로운 가상 처리기(LWP)를 응용 프로그램에게 할당함
3. 응용 프로그램은 새로 할당 받은 가상 처리기에서 upcall처리기를 올려두고 수행함
4. upcall 처리기는 봉쇄 스레드의 상태를 저장하고 봉쇄 스레드가 실행중이던 가상 처리기를 반환함
5. upcall 처리기는 새로운 가상 처리기에서 실행 가능한 다른 커널 스레드를 스케줄링함
6. 봉쇄 스레드가 기다리던 사건이 발생하면 커널은 이전에 봉쇄되었던 사용자 스레드가 이제 실행 가능하다는 사실을 알려주는 또 다른 upcall을 스레드 라이브러리에게 전송함
7. 또 다른 upcall을 처리하기 위해서 커널은 새로운 가상 처리기를 할당한 다음 사용자 스레드를 하나 할당하여 새로운 가상 처리기에서 upcall 처리기를 실행함
8. 봉쇄가 풀린 스레드를 실행 가능 상태로 표시한 후에 응용 프로그램은 사용 가능한 가상 처리기 상에서 다른 실행 가능한 스레드를 실행